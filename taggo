#!/usr/bin/env python

import sys
import os
import re
import ConfigParser

class Taggo:
    debug = False
    config = None
    content_folder = ''
    tags_folder = ''

    def __init__(self, debug=False):
        if debug:
            self.debug = True

        self.mydir = os.path.dirname(os.path.abspath(__file__))
        self.config_file = '%s/taggo.cfg' % self.mydir
        if not os.path.isfile(self.config_file):
            print 'Writing default config to %s\n' % self.config_file
            self.write_config()

        self.config = ConfigParser.RawConfigParser()
        self.config.read(self.config_file)

        self.content_folder = self._get_fullpath('content_folder')
        self.tags_folder = self._get_fullpath('tag_folder')

    def _get_fullpath(self, config_name):
        raw_folder = self.get_config('paths', config_name)
        if raw_folder[0] == '.':
            # Assume relativ path to the script home, as in the docs
            return os.path.abspath('%s/%s' % (self.mydir, raw_folder))
        else:
            return os.path.abspath(raw_folder)

    def help(self):
        print 'Usage: taggo option\n'
        print 'A defalt configuration file will be written if it doesnt exists.\n'
        print 'Options:'
        print '  help           This help'
        print '  run_once       Cleanup first, and then create new tags. Once'
        print '  cleanup        Look for and delete dead symlinks'
        print '  make_tags      Create missing symlink tags'

    def write_config(self):
        config = ConfigParser.RawConfigParser()
        config.add_section('general')
        config.set('general', 'subtag_separator', '- ; Character to split the tag into sub-tags on.')
        config.set('general', 'folder_to_tag_replacer', '_ ; Character that replaces the / when creating tagfiles')
        config.set('general', 'tag_filenames', '%(relative_paths_names)s - %(full_filename)s')

        config.add_section('paths')
        config.set('paths', 'content_folder', './pictures ; Full path or relative to main_folder if it starts with ./')
        config.set('paths', 'tag_folder', './tags ; Full path or relative to main_folder if it starts with ./')

        config_fp = open(self.config_file, 'wb')
        config.write(config_fp)
        config_fp.close()

    def get_config(self, section, item):
        try:
            return self.config.get(section, item)
        except (ConfigParser.NoOptionError, ConfigParser.NoSectionError), e:
            print 'Configuration error: %s' % e
            sys.exit(2)

    def make_tags(self):
        """
        Function that goes trough and creates missing tag folders and missing symlinks
        """

        ignored_subfolders = ['.AppleDouble',]

        folder_to_tag_replacer = self.get_config('general', 'folder_to_tag_replacer')
        subtag_separator = self.get_config('general', 'subtag_separator')
        tag_filenames = self.get_config('general', 'tag_filenames')

        match_num_space = re.compile(r'^[0-9 ]+$')

        if self.debug:
            count = 0

        for root, dirs, files in os.walk(self.content_folder):
            if files:
                replacer = {}
                if root == self.content_folder:
                    # We got loose files in our content folder..
                    path = ['']
                else:
                    path = root.replace(self.content_folder + '/', '', 1).split('/')

                if path[-1:][0] in ignored_subfolders:
                    continue

                replacer['last_path_name'] = path[-1:][0]
                replacer['relative_paths_names'] = folder_to_tag_replacer.join(path)
                for f in files:
                    file_path = '%s/%s' % (root, f)

                    if self.debug:
                        count += 1
                        if count % 1000 == 0: # Status for every 1000
                            print 'Have checked %s, currently on %s' % (count, file_path)

                    f_split = f.split(' ')
                    if len(f_split) <= 1:
                        continue # Didnt find any tags, we asume a space means it have tags..

                    file_id = f_split.pop(0) # Away with the file ID, and grab file_id
                    f_tags = ' '.join(f_split).split('.')[:-1] # Away with fileext

                    replacer['full_filename'] = f
                    replacer['file_id'] = file_id

                    #if self.debug: print '=', file_path

                    for t in ' '.join(f_tags).split(','):
                        tag = t.strip().replace(subtag_separator, '/')
                        tag_folder = '%s/%s' % (self.tags_folder, tag)
                        tag_filename = tag_filenames % replacer

                        if match_num_space.match(tag):
                            continue # Probably errorous tagging..

                        if not os.path.isdir(tag_folder):
                            if self.debug: print '* Creating folder(s) %s' % tag_folder
                            os.makedirs(tag_folder)

                        symlink_path = '%s/%s' % (tag_folder, tag_filename)
                        if not os.path.islink(symlink_path):
                            if self.debug:
                                print 'Source file: %s' % file_path
                                print 'Symlink', symlink_path
                                print
                            os.symlink(file_path, symlink_path)
                        #if self.debug: print '>', symlink_path

    def cleanup(self):
        """
        Goes trough every symlink and check if they are still valid. If they are not, deletes them.
        There is no good way to detect where they belongs now, and make_tags will recreate them with the
        right path
        """

        for root, dirs, files in os.walk(self.tags_folder):
            if files:
                for f in files:
                    if not os.path.exists(os.readlink('%s/%s' % (root, f))):
                        os.unlink('%s/%s' % (root, f))
                        if self.debug: print 'Removing dead link %s/%s' % (root, f)
        if self.debug: print

if __name__ == '__main__':
    taggo = Taggo(debug=True)

    valid_args = ['help', 'make_tags', 'cleanup', 'run_once']

    try:
        arg = sys.argv[1]
    except IndexError:
        arg = 'help'

    if arg not in valid_args: arg = 'help'

    if arg == 'help': taggo.help()
    if arg == 'make_tags': taggo.make_tags()
    if arg == 'cleanup': taggo.cleanup()
    if arg == 'run_once':
        taggo.cleanup()
        taggo.make_tags()
