#!/usr/bin/env python

import sys
import os
import re
import ConfigParser

class Taggo:
    debug = False
    config = None
    content_folder = ''
    tags_folder = ''

    def __init__(self, debug=False):
        if debug:
            self.debug = True

        self.mydir = os.path.dirname(os.path.abspath(__file__))
        self.config_file = '%s/taggo.cfg' % self.mydir
        if not os.path.isfile(self.config_file):
            print 'Writing default config to %s\n' % self.config_file
            self.write_config()

        self.config = ConfigParser.RawConfigParser()
        self.config.read(self.config_file)

        self.content_folder = self._get_fullpath('content_folder')
        self.tags_folder = self._get_fullpath('tag_folder')

    def _get_fullpath(self, config_name):
        raw_folder = self.get_config('paths', config_name)
        if raw_folder[0] == '.':
            # Assume relativ path to the script home, as in the docs
            return os.path.abspath('%s/%s' % (self.mydir, raw_folder))
        else:
            return os.path.abspath(raw_folder)

    def _del_empty_dirs(self, s_dir):
        # Original @ https://gist.github.com/1569173
        # With some small fixes to make it work :)

        b_empty = True

        for s_target in os.listdir(s_dir):
            s_path = os.path.join(s_dir, s_target)
            if os.path.isdir(s_path):
                if not self._del_empty_dirs(s_path):
                    b_empty = False
            else:
                b_empty = False

            if b_empty:
                if self.debug: print 'deleting empty dir %s' % (s_path,)

                # os.rmdir is only allowed to delete empty directories
                os.rmdir(s_path)

        return b_empty


    def help(self):
        print 'Usage: taggo option\n'
        print 'A defalt configuration file will be written if it doesnt exists.\n'
        print 'Options:'
        print '  help             This help'
        print '  run_once         Cleanup first, and then create new tags. Once'
        print '  cleanup          Look for and delete dead symlinks'
        print '  make_tags        Create missing symlink tags'
        print '  rename from to   Example "taggo rename People-Paul People-Family-Paul", or "taggo rename Pau Paul.'

    def write_config(self):
        config = ConfigParser.RawConfigParser()
        config.add_section('general')
        config.set('general', 'subtag_separator', '- ; Character to split the tag into sub-tags on.')
        config.set('general', 'folder_to_tag_replacer', '_ ; Character that replaces the / when creating tagfiles')
        config.set('general', 'tag_filenames', '%(relative_paths_names)s - %(full_filename)s')

        config.add_section('paths')
        config.set('paths', 'content_folder', './pictures ; Full path or relative to main_folder if it starts with ./')
        config.set('paths', 'tag_folder', './tags ; Full path or relative to main_folder if it starts with ./')

        config_fp = open(self.config_file, 'wb')
        config.write(config_fp)
        config_fp.close()

    def get_config(self, section, item):
        try:
            return self.config.get(section, item)
        except (ConfigParser.NoOptionError, ConfigParser.NoSectionError), e:
            print 'Configuration error: %s' % e
            sys.exit(2)

    def rename(self, original, to):
        if self.debug:
            print 'Will rename every tags %s to %s' % (original, to)

    def make_tags(self):
        """
        Function that goes trough and creates missing tag folders and missing symlinks
        """

        ignored_subfolders = ['.AppleDouble', 'iPod Photo Cache',]

        folder_to_tag_replacer = self.get_config('general', 'folder_to_tag_replacer')
        subtag_separator = self.get_config('general', 'subtag_separator')
        tag_filenames = self.get_config('general', 'tag_filenames')

        match_num_space = re.compile(r'^[0-9 ]+$')
        replace_start_num_space = re.compile(r'^[0-9 ]+')


        if self.debug:
            print 'Running make_tags()'
            count = 0

        for root, dirs, files in os.walk(self.content_folder):
            if files:
                replacer = {}
                if root == self.content_folder:
                    # We got loose files in our content folder..
                    path = ['']
                else:
                    path = root.replace(self.content_folder + '/', '', 1).split('/')

                if path[-1:][0] in ignored_subfolders:
                    continue

                replacer['last_path_name'] = path[-1:][0]
                if not replacer['last_path_name']:
                    replacer['last_path_name'] = 'root'

                replacer['relative_paths_names'] = folder_to_tag_replacer.join(path)
                if not replacer['relative_paths_names']:
                    replacer['relative_paths_names'] = 'root'

                for f in files:
                    file_path = '%s/%s' % (root, f)

                    if self.debug:
                        count += 1
                        if count % 1000 == 0: # Status for every 1000
                            print 'Have checked %s, currently on %s' % (count, file_path)

                    f_split = f.split(' ')
                    if len(f_split) <= 1:
                        continue # Didnt find any tags, we asume a space means it have tags..

                    file_id = f_split.pop(0) # Away with the file ID, and grab file_id
                    if f_split[0] == '-':
                        # Filename is in format "dcim001 - some
                        # words", this normally is a sign of a
                        # comment, and we should not tag it.
                        continue

                    f_tags = ' '.join(f_split).split('.')[:-1] # Away with fileext

                    replacer['full_filename'] = f
                    replacer['file_id'] = file_id

                    #if self.debug: print '=', file_path

                    for t in ' '.join(f_tags).split(','):
                        tag = t.strip().replace(subtag_separator, '/')

                        # Take away tags that starts with a number.
                        # Those are probably dated filenames
                        tag = replace_start_num_space.sub('', tag, 1)

                        tag_folder = '%s/%s' % (self.tags_folder, tag)

                        tag_filename = tag_filenames % replacer

                        if not tag: # Might be empty after the applied rules
                            continue

                        if match_num_space.match(tag):
                            continue # Probably errorous tagging..

                        if not os.path.isdir(tag_folder):
                            if self.debug: print '* Creating folder(s) %s' % tag_folder
                            os.makedirs(tag_folder)

                        symlink_path = '%s/%s' % (tag_folder, tag_filename)
                        if not os.path.islink(symlink_path):
                            if self.debug:
                                print 'Source file: %s' % file_path
                                print 'Symlink', symlink_path
                                print
                            os.symlink(file_path, symlink_path)
                        #if self.debug: print '>', symlink_path

    def cleanup(self):
        """
        Goes trough every symlink and check if they are still valid. If they are not, deletes them.
        There is no good way to detect where they belongs now, and make_tags will recreate them with the
        right path

        This is made so it can only possible delete symlinks and empty folders, in other words, it should be very safe to use :)
        """

        if self.debug: print 'Running cleanup()'

        if self.debug: print 'Starting removing dead links'

        for root, dirs, files in os.walk(self.tags_folder):
            if files:
                for f in files:
                    try:
                        full_path = os.path.join(root, f)
                        if not os.path.exists(os.readlink(full_path)):
                            os.unlink(full_path)
                            if self.debug: print 'Removing dead link %s' % full_path
                    except OSError:
                        pass

        if self.debug: print 'Starting removing empty directories'
        self._del_empty_dirs(self.tags_folder)

if __name__ == '__main__':
    taggo = Taggo(debug=False)

    try:
        arg = sys.argv[1]
    except IndexError:
        arg = None

    if arg == 'make_tags':
        taggo.make_tags()
        sys.exit(0)

    if arg == 'cleanup':
        taggo.cleanup()
        sys.exit(0)

    if arg == 'run_once':
        taggo.cleanup()
        taggo.make_tags()
        sys.exit(0)

    if len(sys.argv) == 4:
        if arg == 'rename': taggo.rename(original=sys.argv[2], to=sys.argv[3])
        sys.exit(0)

    taggo.help()
